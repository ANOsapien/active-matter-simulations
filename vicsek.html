<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Vicsek Model</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    body { background:#222; color:white; font-family:Arial; text-align:center; }
    canvas { border:1px solid #555; margin-top:10px; }
    #controls { display:flex; flex-wrap:wrap; justify-content:center; gap:12px; margin-top:12px; }
    label { font-size:13px; }
    button { padding:6px 10px; border-radius:6px; border:none; cursor:pointer; }
  </style>
</head>
<body>
  <h2>Vicsek Model</h2>
  <div id="controls">
    <label>Noise <input id="noiseSlider" type="range" min="0" max="2" step="0.01" value="0.3"></label>
    <label>Speed <input id="speedSlider" type="range" min="0.01" max="3" step="0.01" value="0.3"></label>
    <label>Particles <input id="countSlider" type="range" min="10" max="800" step="10" value="300"></label>
    <label>Particle Size <input id="sizeSlider" type="range" min="3" max="20" step="1" value="8"></label>
    <label>Trail Length <input id="trailSlider" type="range" min="0" max="200" step="1" value="0"></label>
    <label>Interaction Radius <input id="radiusSlider" type="range" min="1" max="20" step="0.5" value="5"></label>
    <button id="startBtn">Start</button>
  </div>

<script>
let particles = [];
let N = 300;
let noiseLevel = 0.3;
let speed = 0.3;
let particleSize = 8;
let trailLength = 0;
let radius = 5;
let running = false;

// Adaptive canvas size
let canvasSize = 800;
function adaptCanvasSize() {
  // If particleSize > 12 and N large, reduce grid size to avoid overcrowding
  canvasSize = particleSize > 12 ? max(400, 800 - particleSize*10) : 800;
  resizeCanvas(canvasSize, canvasSize);
}

class Particle {
  constructor() {
    this.x = random(canvasSize);
    this.y = random(canvasSize);
    this.angle = random(TWO_PI);
    this.history = [];
  }

  update() {
    let prevX = this.x, prevY = this.y;

    // Compute new angle based on neighbors
    // (averaging done in draw loop for performance)
    this.x += speed * cos(this.angle);
    this.y += speed * sin(this.angle);

    // Detect wrap-around and break trail
    if (abs(this.x - prevX) > canvasSize/2 || abs(this.y - prevY) > canvasSize/2) {
      this.history = [];
    }

    // Periodic boundaries
    if (this.x < 0) this.x += canvasSize;
    if (this.y < 0) this.y += canvasSize;
    if (this.x >= canvasSize) this.x -= canvasSize;
    if (this.y >= canvasSize) this.y -= canvasSize;

    // Save trail
    if (trailLength > 0) {
      this.history.push({x:this.x, y:this.y});
      if (this.history.length > trailLength) this.history.shift();
    }
  }

  display() {
    // Draw trail
    if (trailLength > 0 && this.history.length > 1) {
      noFill();
      stroke(255, 255, 0, 90);
      beginShape();
      for (let p of this.history) vertex(p.x, p.y);
      endShape();
    }
    // Draw quiver arrow
    push();
    translate(this.x, this.y);
    rotate(this.angle);
    stroke(255,255,0);
    strokeWeight(2);
    line(0,0, particleSize,0);
    line(particleSize,0, particleSize-4, 2);
    line(particleSize,0, particleSize-4, -2);
    pop();
  }
}

function setup() {
  createCanvas(canvasSize, canvasSize);
  initParticles();

  select('#speedSlider').input(e => speed = parseFloat(e.target.value));
  select('#noiseSlider').input(e => noiseLevel = parseFloat(e.target.value));
  select('#countSlider').input(e => { N = parseInt(e.target.value); initParticles(); });
  select('#sizeSlider').input(e => { particleSize = parseInt(e.target.value); adaptCanvasSize(); });
  select('#trailSlider').input(e => trailLength = parseInt(e.target.value));
  select('#radiusSlider').input(e => radius = parseFloat(e.target.value));
  select('#startBtn').mousePressed(() => {
    running = !running;
    const b = select('#startBtn');
    b.html(running ? 'Stop' : 'Start');
    b.style('background', running ? '#c0392b' : '#27ae60');
  });
}

function initParticles() {
  particles = [];
  for (let i = 0; i < N; i++) particles.push(new Particle());
}

function draw() {
  background(34);

  if (running) {
    // Compute new angles
    let newAngles = [];
    for (let i=0; i<N; i++){
      let p = particles[i];
      let sumSin=0, sumCos=0, count=0;
      for (let j=0;j<N;j++){
        if(i===j) continue;
        let q = particles[j];
        let dx = p.x - q.x;
        let dy = p.y - q.y;
        // periodic distance
        if(abs(dx)>canvasSize/2) dx-=Math.sign(dx)*canvasSize;
        if(abs(dy)>canvasSize/2) dy-=Math.sign(dy)*canvasSize;
        let dist = sqrt(dx*dx + dy*dy);
        if(dist < radius){
          sumSin += sin(q.angle);
          sumCos += cos(q.angle);
          count++;
        }
      }
      if(count>0){
        let avg = atan2(sumSin,sumCos);
        newAngles[i] = avg + random(-noiseLevel/2, noiseLevel/2);
      } else newAngles[i] = p.angle;
    }

    for(let i=0;i<N;i++){
      particles[i].angle = newAngles[i];
      particles[i].update();
    }
  }

  for(let p of particles) p.display();
}
</script>
</body>
</html>
